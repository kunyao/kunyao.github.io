---
layout: post
title: Assignment IIâ€”Mesh Simplification
---
This is the writeup for the second assignment of `CSE 190`. Data structure is everything in this project, so in the beginning, I will briefly summarize my analysis of mesh simplification problem and explain the reason why I choose these structures. After that, I will post up the results from single test models to the large complex ones. 

## Analysis

### General 

Using `indexed face set` with `vertex to face adjacency table` is quite straight forward: `openGL` drawing function only concerns about faces and vertices. And we can not gain much benefit from edges in `edge collapse` process. 

### Edge Collapse

In an `edge collapse` procedure, we need to:

1. Find two vertices **v0**, **v1** in the vertices set. Remove these two vertives and insert a new vertex **v**
2. Find all the faces adjacent to **v0**, **v1**
3. Change all **v0**, **v1** in the adjacent faces to **v**
4. Remove the common faces of **v0**, **v1**
5. Insert adjacent faces of **v**, update the adjacency table for the vertices adjacent to **v0**, **v1**, and remove **v0**, **v1**

Beside that, for illustration, we have to update *vertices normals*, *faces normals* and *faces colors* properly.

### Quadric Simplification

The structure in this section is simple. We need a *Q matrices* structure, which is basically the same as *vertices normals*. In addition, there must be a structure for ordered edges. The total procedure would be like:

1. Find least cost edge **e** = (**v0**, **v1**)
2. Collapse **v0**, **v1**
3. Remove **v0**, **v1** in Q matrices and add **v**
4. Remove **e**, update cost of edges of all vertices adjacent to **v0**, **v1**
5. Sort edges

### Structures and Operations

In sum, we need the structures to do following operations:

| Name             | Contents              | Operations                      |
| :---:            | :--:                  | :---:                           |
| Vertices         | (x,y,z) coordinate(3) | Look up; Insert; Remove         |
| Faces            | vertices index(3)     | Look up; Update; Remove         |
| V2F Adjacency    | faces index(N)        | Look up; Update; Insert; Remove |
| Faces Normals    | (x,y,z) coordinate(3) | Look up; Update; Remove         |
| Vertices Normals | (x,y,z) coordinate(3) | Look up; Update; Insert; Remove |
| Face Colors      | color value(3)        | Look up; Remove                 |
| Q matrices       | Q value(4*4)          | Look up; Insert; Remove         |
| Edges            | cost(1) and vertices index(3)              | Look up; Update; Insert; Remove; Sort                               |
    
    The Number between parenthesis denotes the dimension of each element in its structure. 

    In Faces structure, as I store all of faces adjacent to one vertex, I don't know the number beforehand, so it is a unknown number N. 

*Vertices to vertices adjacency* can be obtained from *Vertices to Faces adjacency* and *Faces*. I don't introduce edges adjacency as it is useless for our purpose. However, there is a special case: connected vertices which don't share a face won't find each other. Assume that there is a 'solitary' triangle **ABC**, if we collapse edge *AB** to **B'** in a way which makes **B'** and **C** adjacent to each other but they don't share a face, next time, when we update **B**, there won't be update with **C**. 

The solution is simple: when we find an edge 'alone', we collapse them right after this time.

### Tricks:

In fact, we don't need to traverse for all vertices related structures.(*Vertices*, *V2F Adjacency*, *Vertices Normals* and *Q matrices*. We have to do that in faces, as we draw for each face)
Therefore, for those 'vertices' structures, we can drop remove operation. Assume that **v0**, **v1** collapse to **v**, we can just let **v** take place of **v0** and keep **v1** where it is. 

### My Structure:

Firstly, to make life easier, I borrow all of the structures from others. For those basic elements, I use those in `GLM` (vec2, vec3, vec4, mat4). With the help of `GLM`, I save much of time implementing vector or matrix calculation. (However, I spend much time debugging it!!!). Moreover, in *Faces*, as I store all of faces adjacent to one vertex, I don't know the number beforehand, so I use `vector`.

With the tricks I mention in the last section, for *Vertices*, *V2F Adjacency*, *Vertices Normals* and *Q matrices* structure, I only need look up and update operation, therefore `vector` is the best choice.

For *Edges*, we have to do sort, loop up and remove. There is no way to get complexity less than Olog(#e) for each simplification. (#e denotes the number of edges). Heap and priority queue are good choice. However, I have to write comparison function myself. I choose `map` which use red-black tree. It can be proved to insert and remove with Olog(#e). 

For *Faces*, *Face Colors*, *Faces Normals* the key problem is that we are required to do look up and remove operation in constant time. My lazy solution is used `hash` which has average and amortized constant running time. Honestly, I don't know how `STL` hash(`unordered_map`) is implemented in very details. However, I think it is an acceptable solution, as we can only achieve edges' operation in Olog(#e). 

Therefore, all the data structures I use:

| Name             | Data Structure           |
| :---:            | :--:                     |
| Vertices         | vector<vec3>             |
| Faces            | unordered_map<int, vec3> |
| V2F Adjacency    | vector<vector<int> >     |
| Faces Normals    | unordered_map<int, vec3> |
| Vertices Normals | vector<vec3>             |
| Face Colors      | unordered_map<int, vec3> |
| Q matrices       | vector<mat4>             |
| Edges            | map<float,vec2>          |





