---
layout: post
title: Assignment IIâ€”Mesh Simplification
---
This is the writeup for the second assignment of `CSE 190`. Data structure is everything in this project, so in the beginning, I will briefly summarize my analysis of mesh simplification problem and explain the reason why I choose these structures. After that, I will post up the results from single test models to the large complex ones. 

## Analysis

### General 

Using `indexed face set` with `vertex to face adjacency table` is quite straight forward: `openGL` drawing function only concerns about faces and vertices. And we can not gain much benefit if we introduce edges in `edge collapse` process. However we have to do write down every step in details before we choose the specific structure.

### Edge Collapse

In an `edge collapse` procedure, we need to:

1. Find two points **v0**, **v1** in the vertices set. Remove these two vertives and insert a new vertex **v**
2. Find all the faces adjacent to **v0**, **v1**
3. Change all **v0**, **v1** in the adjacent faces to **v**
4. Remove the common faces of **v0**, **v1**
5. Insert **v** in adjacency table and update the adjacency table for the vertices adjacent to **v0**, **v1**. And remove **v0**, **v1**

Beside that, for illustration, we have to update *vertices normals*, *faces normals* and *face colors* properly.

### Quadric Simplification

The structure in this section is simple. We need a *Q matrices* structure, which is basically the same as *vertices normals*. In addition, there must be a structure for ordered edges. The total procedure would be like:

1. Find least cost edge **e** = (**v0**, **v1**)
2. Do edge collapse with **v0**, **v1**
3. Remove **v0**, **v1** in Q matrices and add **v0**
4. Remove **e**, update cost of edges of all vertices adjacent to **v0**, **v1**
5. Re-order edges

### Structures and Operations

In sum, we need the date structures to do following operations:

| Name             | Contents              | Operations                      |
| :---:            | :--:                  | :---:                           |
| Vertices         | (x,y,z) coordinate(3) | Look up; Insert; Remove         |
| Faces            | vertices index(3)     | Look up; Update; Remove         |
| V2F Adjacency    | faces index(N)        | Look up; Update; Insert; Remove |
| Faces Normals    | (x,y,z) coordinate(3) | Look up; Update; Remove         |
| Vertices Normals | (x,y,z) coordinate(3) | Look up; Update; Insert; Remove |
| Face Colors      | color value(3)        | Look up; Remove                 |
| Q matrices       | Q value(4*4)          | Look up; Insert; Remove         |
| Edges            | cost(1) and vertices index(3)              | Look up; Update; Insert; Remove; sort                               |
    
    The Number between parenthesis denotes the dimension of each element in its structure. For example, in Face Colors structure, there will be **RGB** three value. In Faces structure, as I store all of faces adjacent to one vertex, I don't know the number beforehand, so it is a unknown number N. 

*Vertices to vertices adjacency* can be obtained with *Vertices to Faces adjacency* and *Faces*. I don't introduce edges for convenience, however, there might be a flaw: the connected vertices which don't share a face won't find each other. Assume that there is a triangle **ABC**, if we collapse edge *AB** to **B** in a way which makes **B** and **C** adjacent to each other but they don't share the same face, next time, when we update **B**, there won't be update with **C**. 

The solution is simple: when we find an edge 'alone', we collapse them right after this time.

### Tricks:

In fact, we don't need to traverse for all the structure relate to vertices.
(We have to do that in faces, as we draw for each face)
Therefore, for those 'vertices' structures, we can drop remove operation. For example, for *Vertices*, we can just make **v** take place of **v0**. The same trick can be also used for *V2F Adjacency*, *Vertices Normals* and *Q matrices*.
### My Structure:

Firstly, to make life easier, I borrow all of the structures. For those basic elements, I use elements in `GLM` (vec2, vec3, vec4, mat4). With the help of `GLM`, I save much of time implementing vector or matrix calculation. (However, I spend much time debugging it!!!). Moreover, in *Faces*, as I store all of faces adjacent to one vertex, I don't know the number beforehand, so I use `vector` to store.

With the tricks I mention in the last section, for *Vertices*, *V2F Adjacency*, *Vertices Normals* and *Q matrices* structure, I only need look up and update operation, therefore `vector` is the best choice.

For *Edges*, we have to do sort, loop up and remove. There is no way to get complexity less than Olog(#e) for each simplification. (#e denotes the number of edges). Heap and priority queue are good choice. However, I have to write comparison function myself for *Edges* structure with heap. Priority queue is not complete either. I choose `map` which use red-black tree. It can be proved to insert and remove with Olog(#e). Also it can sort automatically.

For *Faces*, *Face Colors*, *Faces Normals* the key problem is that we are required to do look up and remove operation in constant time. My lazy solution is used `hash` which has average and amortized constant running time. Honestly, I don't know how `STL` hash(`unordered_map`) is implemented in much details. However, I think it is an acceptable solution, as we can only achieve edges' operation in Olog(#e). 

Therefore, all the structures I use:

| Name             | Data Structure           |
| :---:            | :--:                     |
| Vertices         | vector<vec3>             |
| Faces            | unordered_map<int, vec3> |
| V2F Adjacency    | vector<vector<int> >     |
| Faces Normals    | unordered_map<int, vec3> |
| Vertices Normals | vector<vec3>             |
| Face Colors      | unordered_map<int, vec3> |
| Q matrices       | vector<mat4>             |
| Edges            | map<float,vec2>          |





