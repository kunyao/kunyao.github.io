---
layout: post
title: Assignment Iâ€”Image and Signal Processing
---
This is a writeup for the first assignment of `CSE 190`. With great fun in this three weeks, I implement all of the techniques except convolution in frequency domain and compositing. As I complete this project all by myself, please don't criticize me too much on not leaving enough comments on the source code. I will try my best to explain my work in this instruction. 

## Basic Operations
There is nothing complex in this section. I will briefly post up my result below. 

### Brighten
Using command:
{% highlight cpp %}
./image -brightness factor <flower.bmp >out.bmp
{% endhighlight %} 
With factor: **0.0,0.5,1.0,1.5,2.0**

 <img src="../img/bri0.bmp" /> | <img src="../img/bri0.5.bmp" /> | <img src="../img/bri1.bmp" /> | <img src="../img/bri1.5.bmp" /> | <img src="../img/bri2.bmp" /> | 
:-:|:-:|:-:|:-:|:-:
0.0|0.5|1.0|1.5|2.0        


For negative factor, it will return:
{% highlight cpp%}
The factor should be non-negative
{% endhighlight %} 

### Change Contrast
Using command:
{% highlight cpp %}
./image -contrast factor <flower.bmp >out.bmp
{% endhighlight %} 
With factor: **-0.5,0.0,0.5,1.0,1.7** 

 <img src="../img/contr-0.5.bmp" /> | <img src="../img/contr0.0.bmp" /> | <img src="../img/contr0.5.bmp" /> | <img src="../img/contr1.0.bmp" /> | <img src="../img/contr1.7.bmp" /> | 
:--:|:-:|:-:|:-:|:-:
-0.5|0.0|0.5|1.0|1.7  

### Change Saturation
Using command:
{% highlight cpp %}
./image -saturation factor <flower.bmp >out.bmp
{% endhighlight %} 
With factor: **-1.0,0.0,0.5,1.0,2.5** 

 <img src="../img/satur-1.0.bmp" /> | <img src="../img/satur0.0.bmp" /> | <img src="../img/satur0.5.bmp" /> | <img src="../img/satur1.0.bmp" /> | <img src="../img/satur2.5.bmp" /> | 
:--:|:-:|:-:|:-:|:-:
-1.0|0.0|0.5|1.0|2.5 


### Change Gamma
Using command:
{% highlight cpp %}
./image -gamma factor <flower.bmp >out.bmp
{% endhighlight %} 
With factor: **0.5,1.0,1.5,2.0** 

 <img src="../img/gam0.5.bmp" /> | <img src="../img/gam1.0.bmp" /> | <img src="../img/gam1.5.bmp" /> | <img src="../img/gam2.0.bmp" /> 
 :--:|:-:|:-:|:-:|:-:
0.5|1.0|1.5|2.0


For negative or zero factor, it will return:
{% highlight cpp%}
The factor should be positive
{% endhighlight %} 

### Crop
Using command:
{% highlight cpp %}
./image -crop x y w h <flower.bmp >out.bmp
{% endhighlight %} 

With factor:**(x,y,w,h)=(50,30,80,80)**

<img src="../img/crop.bmp" style="display:inline"/>

If the location (x,y,x+w,y+h) is not valid, it will return:
{% highlight cpp%}
The corner location is not valid
{% endhighlight %} 

If either w or h is less than zero, it will return:
{% highlight cpp%}
Width and height should be positive
{% endhighlight %} 

## Quantization and Dithering

This section is not hard either. I will show the results in the form below. Here are three points I need to mention:

Firstly, `FloydSteinbergDither` is a little annoying in that we have to handle float and negative pixel value. For this problem, I pick out the operation part into a single function, `int` in `int` out and process all of the float data inside. I have to commit that this is a quite lazy way to do. For more complex calculation problem like convolution below, I implement a new class named fPixel for storing and calculating float value pixels. Almost all of the function after convolution require float operation potentially, therefore it is quite worthwhile to create this new class. 
	  
Moreover, handling edge pixels is another problem for `FloydSteinbergDither`. Honestly, I don't care much about these edge pixels in my former image processing work. I used to fill zeros or mirror symmetry values to the edge. Therefore, this time, I try both of the methods mentioned in the assignment instruction: `renormalization` and `toroidal extension`. (I use variable solution to choose two methods in the code)

Also, I try some nonlinear mapping in quantization. You can see the results in the last row of the form. I use a mapping function like gamma correctness: (I use variable solution to choose two methods(linear mapping or nonlinear mapping) in the code)

{% highlight cpp %}
q = floor(p/256*b)
w = pow(q/b,factor)
c = floor(255*b*w/(b-1))
{% endhighlight %}

### Results:

\#Bits|1 | 2 | 3 | 4 | 5 |
 :--:|:-:|:-:|:-:|:-:|:-:|
Quan(L)|<img src="../img/quan1.bmp" /> |<img src="../img/quan2.bmp" />|<img src="../img/quan3.bmp" />|<img src="../img/quan4.bmp" />|<img src="../img/quan5.bmp" />
Random|<img src="../img/rand1.bmp" /> |<img src="../img/rand2.bmp" />|<img src="../img/rand3.bmp" />|<img src="../img/rand4.bmp" />|<img src="../img/rand5.bmp" />
FS|<img src="../img/floyd1.bmp" /> |<img src="../img/floyd1.bmp" />|<img src="../img/floyd1.bmp" />|<img src="../img/floyd1.bmp" />|<img src="../img/floyd1.bmp" />
 

## Summary


