---
layout: post
title: Assignment Iâ€”Image and Signal Processing
---
This is the writeup for the first assignment of `CSE 190`. 
I implement all of the techniques except convolution in frequency domain and compositing. 
The mathematics is not complex in this project, most of the work is completed by 
manipulating either pixel value or pixel coordinate directly. Therefore, I will mainly post up
outcomes without mentioning implementing details which are already well written in the assignment instruction.

 
## Basic Operations

### Brighten

Brighten flower.bmp with factor: **0.0,0.5,1.0,1.5,2.0**

 <img src="../img/bri0.bmp" /> | <img src="../img/bri0.5.bmp" /> | <img src="../img/bri1.bmp" /> | <img src="../img/bri1.5.bmp" /> | <img src="../img/bri2.bmp" /> | 
:-:|:-:|:-:|:-:|:-:
0.0|0.5|1.0|1.5|2.0        

For negative factor, it will return:
{% highlight cpp%}
The factor should be non-negative
{% endhighlight %} 

### Change Contrast

Change Contrast of flower.bmp with factor: **-0.5,0.0,0.5,1.0,1.7** 

 <img src="../img/contr-0.5.bmp" /> | <img src="../img/contr0.0.bmp" /> | <img src="../img/contr0.5.bmp" /> | <img src="../img/contr1.0.bmp" /> | <img src="../img/contr1.7.bmp" /> | 
:--:|:-:|:-:|:-:|:-:
-0.5|0.0|0.5|1.0|1.7  

### Change Saturation

Change Saturation of flower.bmp with factor: **-1.0,0.0,0.5,1.0,2.5** 

 <img src="../img/satur-1.0.bmp" /> | <img src="../img/satur0.0.bmp" /> | <img src="../img/satur0.5.bmp" /> | <img src="../img/satur1.0.bmp" /> | <img src="../img/satur2.5.bmp" /> | 
:--:|:-:|:-:|:-:|:-:
-1.0|0.0|0.5|1.0|2.5 


### Change Gamma

Change Gamma of flower.bmp with factor: **0.5,1.0,1.5,2.0** 

 <img src="../img/gam0.5.bmp" /> | <img src="../img/gam1.0.bmp" /> | <img src="../img/gam1.5.bmp" /> | <img src="../img/gam2.0.bmp" /> 
 :--:|:-:|:-:|:-:|:-:
0.5|1.0|1.5|2.0


For negative or zero factor, it will return:
{% highlight cpp%}
The factor should be positive
{% endhighlight %} 

### Crop

Crop flower.bmp with factor:**(x,y,w,h)=(50,30,80,80)**

<img src="../img/crop.bmp" style="display:inline"/>

If the location (x,y,x+w,y+h) is not valid, it will return:
{% highlight cpp%}
The corner location is not valid
{% endhighlight %} 

If either w or h is less than zero, it will return:
{% highlight cpp%}
Width and height should be positive
{% endhighlight %} 

## Quantization and Dithering

Results can be compared with the table below. Here are three points I need to mention:

Firstly, as we know, `FloydSteinbergDither` is a little annoying in that we have to handle potential decimal and negative pixel value. For this problem, I pick out the whole calculation part into a single function, which is `Pixel` in `Pixel` out but process all of the data as float type inside the function.
{% highlight cpp%}
Pixel FloydSteinOperator (const Pixel& w, const Pixel& p, const Pixel& q, double t);
{% endhighlight %} 

Moreover, handling edge pixels is another problem for `FloydSteinbergDither`. Honestly, I don't care much about these edge pixels in my former image processing work. I used to fill zeros or mirror symmetry values around the edges. In this project, I try both of the methods mentioned in the assignment instruction: `renormalization` and `toroidal extension`. I won't post up all of the outcome created by these two methods. The only difference lies on the 
edges which can barely be discriminated. In my source code, you can change method with the variable `solution`. 
As `toroidal extension` is easier to implement and expend to other cases. I write a separate function for it:
{% highlight cpp%}
Image* Image::Expand(int n);
{% endhighlight %} 

In addition, I try non-linear mapping in quantization. I use a mapping function like gamma correctness:
{% highlight cpp %}
q = floor(p/256*b)
w = pow(q/b,factor)
c = floor(255*b*w/(b-1))
{% endhighlight %}
It is controlled by the variable `solution`.

### Results:

\#Bits|1 | 2 | 3 | 4 | 5 |
 :--:|:-:|:-:|:-:|:-:|:-:|
Quan(L)|<img src="../img/quan1.bmp" /> |<img src="../img/quan2.bmp" />|<img src="../img/quan3.bmp" />|<img src="../img/quan4.bmp" />|<img src="../img/quan5.bmp" />
Random|<img src="../img/rand1.bmp" /> |<img src="../img/rand2.bmp" />|<img src="../img/rand3.bmp" />|<img src="../img/rand4.bmp" />|<img src="../img/rand5.bmp" />
FS|<img src="../img/floyd1.bmp" /> |<img src="../img/floyd2.bmp" />|<img src="../img/floyd3.bmp" />|<img src="../img/floyd4.bmp" />|<img src="../img/floyd5.bmp" />
Quan(NL)|<img src="../img/quann1.bmp" /> |<img src="../img/quann2.bmp" />|<img src="../img/quann3.bmp" />|<img src="../img/quann4.bmp" />|<img src="../img/quann5.bmp" />


> Quan(L): Normal Quantization   
Random: Random Dither   
FS: FloydSteinberg Dither   
Quan(NL): non-linear Quantization  

 

## Quantization and Dithering

I have to commit that this is a quite lazy way to do. For more complex calculation problem like convolution below, I implement a new class named fPixel for storing and calculating float value pixels. Almost all of the function after convolution require float operation potentially, therefore it is quite worthwhile to create this new class. 

## Summary


